# CAS 락 구현1

CAS는 단순한 연산 뿐만 아니라, 락을 구현하는데 사용 가능

`synchronized`, `Lock(ReentrantLock)` 없이 CAS를 활용해서 락을 구현할 것

```java
public class SpinLockBad {
    private volatile boolean lock = false;

    public void lock() {
        log("락 획득 시도");
        while(true) {
            if (!lock) { // 1. 락 사용 여부 확인
                sleep(100); // 문제 상황 확인용, 스레드 대기
                lock = true;    // 2. 락의 값 변경
                break;
            } else {
                // 락을 획득할 때 까지 스핀 대기(바쁜 대기)
                log("락 획득 실패 - 스핀 대기");
            }
        }
        log("락 획득 완료");
    }
    
    public void unlock() {
        lock = false;    // 락의 값 변경, 원자적 연산
        log("락 반납 완료");
    }
}
```

실행 결과 기대와는 다르게 `Thread-1`, `Thread-2` 둘다 동시에 락을 획득하고 동시에 수행

어디가 문제인가?

다음 두 부분이 원자적이 않음

- 락 사용 여부 확인(1번)
- 락의 값 변경(2번)

다른 해결 방안은 두 코드를 하나로 묶어서 원자적으로 처리하는 것

CAS 연산을 사용하면 두 연산을 하나로 묶어서 하나의 원자적인 연산으로 처리할 수 있음

락의 사용 여부를 확인하고, 그 값이 기대하는 값과 같다면 변경 = CAS 연산에 딱 들어 맞음

> 참고로 락을 반납하는 연산은 하나의 원자적 연산

# CAS 락 구현2

```java
public class SpinLock {
    private final AtomicBoolean lock = new AtomicBoolean(false);

    public void lock() {
        log("락 획득 시도");
        while(!lock.compareAndSet(false, true)) {
            // 락을 획득할 때 까지 스핀 대기(바쁜 대기)
            log("락 획득 실패 - 스핀 대기");
        }
        log("락 획득 완료");
    }

    public void unlock() {
        lock.set(false);
        log("락 반납 완료");
    }
}
```

CAS 연산을 지원하는 `AtomicBoolean`을 사용

구현 원리는 단순

- 스레드가 락을 획득하면 `lock`의 값이 `true`가 됨
- 스레드가 락을 반납하면 `lock`의 값이 `false`가 됨
 
- 스레드가 락을 획득하면 while 문을 탈출
- 스레드가 락을 획득하지 못하면 락을 획득할 때까지 while 문을 계속 반복 실행

락 획득시 다음 두 연산을 하나로 만들어야 함

1. **락 사용 여부 확인**
2. **락의 값 변경**

```java
while() {
    if (!lock) {    // 1. 락 사용 여부 확인
        lock = true; // 2. 락의 변경
    }
}
```

```java
while(lock.compareAndSet(false, true)) {}
```

CAS 연산 덕분에 원자적이지 않은 두 연산이 하나의 원자적 연산으로 바뀜

1. **락을 사용하지 않는다면 락의 값을 변경**

원자적인 연산은 스레드 입장에서 쪼갤 수 없는 하나의 연산

따라서 여러 스레드가 동시에 실행해도 안전

CAS를 사용해서 원자적인 연산을 만든 덕분에 무거운 동기화 작업 없이 아주 가벼운 락을 만들수 있음

동기화 락을 사용하는 경우 스레드가 락을 획득하지 못하면 `BLOCKED`, `WAITING` 등으로 상태가 변함 (cotext switching이 발생함)

대기 상태의 스레드를 깨워야 하는 무겁고 복잡한 과정이 추가로 들어감, 따라서 성능이 상대적으로 느릴 수 있음

반면 CAS를 활용한 락 방식은 사실 락이 없음

따라서 대기하는 스레드도 `RUNNABLE` 상태를 유지하면서 가볍고 빠르게 작동

## CAS 단점

락을 기다리는 스레드가 `BLOCKED`, `WAITING` 상태로 빠지지 않지만, `RUNNABLE` 상태로 락을 획득할 때까지 `while`문을 반복하는 문제 존재

즉 락을 기다리는 스레드가 CPU를 계속 사용하면서 대기하는 것

`BLOCKED`, `WAITING` 상태의 스레드는 CPU를 거의 사용하지 않지만, `RUNNABLE` 상태로 while 문을 반복 실행하는 방식은 CPU 자원을 계속해서 사용하는 것 임

동기화 락을 사용하면 `RUNNABLE` 상태의 스레드가 `BLOCKED`, `WAITING` 상태에서 다시 `RUNNABLE` 상태로 이동함, 이 사이에 CPU 자원을 거의 사용하지 않음

언제 이런 방식이 효율적인가?

안전한 임계 영역이 필요하지만 연산이 길지 않고, 아주 아주 아주 짧게 끝날 때 사용함

예를 들어 숫자 값의 증가, 자료 구조의 데이터 추가와 같이 CPU 사이클이 금방 끝나는 연산에 사용하면 효과적

반면 데이터베이스 결과를 대기하거나 다른 서버의 요청을 기다리는 것 처럼 오래 기다리는 작업에 사용하면 CPU를 계속 사용하여 최악의 결과 발생

**스핀 락**

스레드가 락이 해제되기를 기다리면서 반복문을 통해 계속해서 확인하는 모습이 마치 제자리에서 회전(spin)하는 것처럼 보임

그래서 이런 방식을 "스핀 락"이라고 부름

스레드가 락을 획들 할 때까지 대기하는 것을 스핀 대기(spin-wait) 또는 CPU 자원을 계속 사용하면서 바쁘게 대기한다고 해서 바쁜 대기(busy-wait)이라 함

스핀 락 방식은 아주 짧은 CPU 연산을 수행할 때 사용하여야 효율적

잘못 사용하면 오히려 CPU 자원을 더 많이 사용

# 정리

## 락 vs CAS 사용 방식

**CAS의 장점**

1. 낙관적 동기화: 락을 걸지 않고도 값을 안전하게 업데이트, CAS 충돌이 자주 발생하지 않을 것이다고 가정(충돌이 적은 환경에서 높은 성능 발휘)
2. 락 프리(Lock-Free): CAS는 락을 사용하지 않기에 락 획득을 위한 대기 시간이 없음, 스레드가 블로킹 되지 않으며 병렬 처리가 더 효육적일 수 있음

**CAS의 단점**

1. 충돌이 빈번한 경우: 충돌 발생 시 CAS는 루프를 돌며 재시도, 따라서 CPU 자원을 계속 소모, 반복전인 재시도로 오버헤드 발생
2. 스핀락과 유사한 오버헤드: CAS는 충돌 시 반복적인 재시도를 하므로 이 과정에서 스핀락과 유사한 성능 저하가 발생할 수 있음(충돌 빈도가 높을 수록 이런 현상이 두드러짐)

**동기화 락의 장점**

1. 충돌 관리: 락을 사용하면 하나의 스레드만 리소스에 접근 할 수 있으므로 충돌 발생하지 않음, 여러 스레드가 경쟁할 경우도 안정적으로 동작
2. 안정성: 복잡한 상황에서도 락은 일관성 있는 동작 보장
3. 스레드 대기: 락을 대기하는 스레드는 CPU를 거의 사용하지 않음

**동기화 락의 단점**

1. 락 획득 대기 시간: 스레드가 락을 획득하기 위해 대기, 대기 시간이 길어질수 있음
2. 컨텍스트 스위칭 오버헤드: 락을 사용하면 락 획득을 대기하는 시점과 또 락을 획득하는 시점에 스레드의 상태가 변경, 이때 컨텍스트 스위칭 발생

**결론**

일반적으로 동기화 락을 사용, 아주 특별한 경우 한정 CAS 사용하여 최적화

**실무 관점**

대부분의 애플리케이션들은 공유 자원을 사용할 때, 충돌할 가능성보다 충돌하지 않을 가능성이 훨씬 높음

여러 스레드에서 발생하는 주문 수를 실시간으로 증가하면서 카운트 한다고 가정

특정 피크시간에 주문이 100만건 들어오는 서비스라고 가정

- 1,000,000 / 60분 = 1분에 16,666건 = 1초에 277건

CPU가 1초에 얼마나 많은 연산을 처리하는지 생각해 보면 백만건 중에 충돌이 발생하는 경우는 넉넉하게 해도 몇 십건 이하

따라서 실무에서는 주문 수 증가와 같은 단순한 연산의 경우, 락을 걸로 시작하는 것보다는 CAS 처럼 낙관적인 방식이 더 나은 성능을 보임

반면 데이터베이스를 기다린다거나 다른 서버의 요청을 기다리는 것 처럼 수 밀리초 이상의 시간이 걸리는 작업은 CAS를 사용하는 것보다 동기화 락을 사용하거나 스레드가 대기하는 방식이 더 효과적

우리가 사용하는 많은 자바 동시성 라이브러리들, 동기화 컬렉션들은 성능 최적화를 위해 CAS 연산을 적극 활용

덕분에 실무에서 직접 CAS 연산을 사용하는 일은 적음, 대신 CAS 연산을 사용해서 최적화 되어 있는 라이브러리들을 이해하고 편리하게 사용할 수 있어야함
