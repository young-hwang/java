## Yield

yield는 스레드의 상태가 변하지 않음(Runnable 상태 유지)
Runnable 상태를 유지하며 다음 동작에 실행 되도록 대기

sleep(1)을 사용시
- RUNNABLE -> TIMED_WAITING 으로 변경
- CPU 자원을 사용하지 않고 실행 스케줄링에서 잠시 제외
- TIMED_WAITING -> RUNNABLE 상태가 되면 스케줄링에 포함
- TIMED_WAITING 상태가 되면서 다른 스레드에 실행을 양보하게 되어 스케줄링 큐에 대기 중인 다른 스레드가 CPU 실행 기회를 빨리 얻음

- RUNNABLE -> TIMED_WAITING -> RUNNABLE 로 복잡한 과정을 거치고 특정 시간만틈 스레드가 실행되지 않는 단점 존재
- e.g. 양보할 스레드가 없다면 자신의 스레드를 더 실행하는 것이 나은 선택

이를 보완할 방법인 바로 **YIELD**

자바의 스레드가 RUNNABLE 상태일 때, 운영체제의 스케줄링은 다음 상태를 가짐
- 실행 상태(RUNNING):  스레드가 CPU에서 실제로 실행 중
- 실행 대기 상태(Ready): 스레드가 실행될 준비가 되었지만 CPU가 바빠서 스케줄링 큐에 대기중
운영체제는 실행 상태의 스레드를 잠깐만 실행하고 실행 대기 상태로 만든다.
실행 대기 상태의 스레드들을 잠깐만 실행 상태로 변경해서 실행한다.
자바에서는 두 상태를 구분할 수 없다.
 
### yield의 작동

- Thread.yield() 메소드는 현재 실행중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행되도록 한다.
- yield() 메소드를 호출한 스레드는 RUNNABLE 상태를 유지하면서 CPU를 양보한다. 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.
- 현재 실행 중인 스레드가 CPU를 양보하도록 힌트만 줄 뿐 강제적인 실행 순서를 지정하지 않는다. 그리고 반드시 다른 스레드가 실행되는 것도 아니다.

> yield()는 RUNNABLE 상태를 유지하기 때문에 양보할 사람이 없다면 본인 스레드가 계속 실행된다
 
 

