# 스트림 시작 1

자바가 가진 데이터를 `hello.dat`라는 파일에 저장하려면 어떻게 해야 하나?

자바 프로세스가 가지고 있는 데이터를 밖으로 보내려면 출력 스르팀을 사용하면 되고, 반대로 외부 데이터르 자바 프로세스 안으로 가져오려면 입력 스트림을 사용하면 됨

각 스트림은 단방향으로 흐름

## 스트림 시작 - 예제 1

> StreamStartMainV1 참조
> 

**new FileOutputStream("temp/hello.dat")**

- 파일에 데이터를 출력하는 스트림
- 파일이 없으면 파일을 자롱으로 만들고 데이터를 해당 파일에 저장
- 폴더를 만들지는 않기 때문에 폴더는 미리 만들어 두어야함

**write()**

- byte 단위로 값을 출력
- 65, 65, 67 출력

**new FileInputStream("temp/hello.dat")**

- 파일에서 데이터를 읽어오는 스트림

**read()**

- 파일에서 데이터를 byte 단위로 하나씩 읽어옴
- 순서대로 65, 66, 67을 읽어옴
- 파일의 끝에 도달해서 더이상 읽을 내용이 없다면 -1 반환
  - 파일의 끝(EOF, End of File)

**close()**

- 파일에 접근하는 것은 자바 입장에서 외부 자원을 사용하는 것임
- 자바에서 내부 객체는 자동으로 GC가 되지만 외부 자원은 사용 후 반드시 닫아주어야 함

**실행 결과**

```shell
65
66
67
-1
```

- 입력한 순서대로 축력되는 것 확인, 마지막 파일의 끝에 도달해서 -1이 출력

**실행 결과 - temp/hello.dat**

```shell
ABC
```

- `hello.dat`에 분명 byte로 65, 66, 67을 저장, 왜 개발툴이나 텍스트 편집기에서 열어보면 ABC라고 표현되는가?
- read()로 읽어서 출력한 경우에는 65, 66, 67이 정상 출력
- 개발툴이나 텍스트 편집기는 UTF-8 또는 MS949 문자 집합을 사용해서 byte 단위의 데이터를 문자로 디코딩해서 보여줌

**참고: 파일 append옵션**

`FileOutputStream`의 생성자에는 `append` 라는 옵션이 존재

```java
new FileOutputStream("temp/hello.dat", true);
```

- `true`: 기존 파일의 끝에 이어서 씀
- `false`: 기존 파일의 데이터를 지우고 처음부터 다시 씀(기본값)

## 스트림 시작 - 예제 2

파일의 데이터를 읽을 때 파일의 끝까지 읽어야 한다면 다음과 같이 반복문을 사용

> StreamStartMainV2 참조

- 입력 스트림의 read() 메소드는 파일의 끝에 도달하면 -1을 반환, 따라서 -1을 반환할 때까지 반복문을 사용하면 파일의 데이터를 모두 읽을 수 있음

**실행 결과**

```shell
65
66
67
```

**참고 - read()가 int를 반환하는 이유**

- 부호 없는 바이트 표현:
  - 자바에서 byte는 부호 있는 8비트 값(-128 ~ 127)
  - int로 반환함으로써 0에서 255까지의 모든 가능한 바이트 값을 부호 없이 표현할 수 있음
- EOF(End of File)표시:
  - byte를 표현하려면 256 종류의 값을 모두 사용해야 함
  - 자바의 byte는 -128에서 127까지 256종류의 값만 가실 수 있어, EOF를 위한 특별한 값을 할당하기 어려움
  - int는 0-255까지 모든 가능한 바이트 값을 표현하고, 여기에 추가로 -1을 반환하여 스트림의 끝(EOF)를 나타낼수 있음
- 참고로 write()의 경우도 비슷한 이유로 int 타입을 입력 받음

# 스트림 시작 2

## 스트림 시작 - 예제 3

byte를 하나씩 다루는 것이 아니라 byte[]을 사용해서 데이터를 원하는 만큼 더 편리하게 저정하고 읽는 방법을 알아봄

> StreamStartMainV3 참조

**실행 결과**

```shell
readCount = 3
[65, 66, 67, 0, 0, 0, 0, 0, 0, 0]
```

**출력 스트림**

- `write(byte[])`: `byte[]`에 원하는 데이터를 담고 `write()`에 전달하면 해당 데이터를 한 번에 출력할 수 있음

**입력 스트림**

- `read(byte[], offset, length)`: `byte[]`을 미리 만들어두고, 만들어둔 `byte[]`에 한 번에 데이터를 읽어올 수 있음
- `byet[]`: 데이터가 읽혀지는 버퍼
- `offset`: 데이터 기록되는 `byte[]`의 인덱스의 위치
- `length`: 읽어올 byte의 최대 길이
- 반환값: 버퍼에 읽은 총 바이트 수 여기서는 3byte를 읽었으므로 3이 반환, 스트림의 끝에 도달하여 더 이상 데이터가 없는 경우 -1 반환

**read(byte[])**

`offset`, `length`를 생략한 `read(byte[])` 메서드도 있음
  - offset: 0
  - length: byte[].length

## 스트림 시작 - 예제 4

모든 byte 한번에 읽기

> StreamStartMainV4 참조

- `readAllBytes()`를 사용하면 스트림이 끝날 때 까지(파일의 끝에 도달할 때 까지) 모든 데이터를 한 번에 읽음

**실행 결과**

```shell
[65, 66, 67]
```

## 부분으로 나누어 읽기 vs 전체 읽기

- `read(byte[], offset, length)`
  - 스트림의 내용을 부분적으로 읽거나, 읽은 내용을 처리하면서 스트림을 계속해서 읽어야 할 경우 적합
  - 메모리 사용량을 제어 할 수 있음
  - 100M의 파일을 1M 단위로 나누어 읽고 처리하는 방식을 사용하면 한 번에 최대 1M의 메모리만 사용
- `readAllBytes()`
  - 한 번의 호출로 모든 데이터를 읽을 수 있어 편리
  - 작은 파일이나 메모리에 모든 내용을 올려서 처리해야 하는 경우에 적합
  - 메모리 사용량을 제어할 수 없음
  - 큰 파일의 경우 OutOfMemoryError 발생 할 수 있음


